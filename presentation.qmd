---
title: "ASML Stock Price Analysis"
subtitle: "Project of Time Series Analysis for Economic and Financial Data"
author: "Daniele Tambone"
date: last-modified
format: 
  revealjs:
    theme: simple
    transition: slide
    slide-number: true
    preview-links: true
    logo: "https://images.squarespace-cdn.com/content/v1/60056c48dfad4a3649200fc0/1611077270135-4EXXT2EB9JJS30OW6ERW/unict-logo.png"
    footer: "[View Full Report](https://danielet25.github.io/ASML-Stock-Price-Analysis/)"
    embed-resources: true
execute:
  echo: false
  warning: false
  fig-width: 6
  fig-height: 4
---

```{r}
#| label: setup
#| include: false

source(here::here("_setup.R"))
asml <- readRDS(here::here("data", "asml_data.rds"))

log_ret_vec <- diff(log(asml$ASML.Adjusted))
log_ret_vec <- log_ret_vec[is.finite(log_ret_vec)]
log_returns <- data.frame(Date = asml$Date[-1], LogReturns = as.numeric(log_ret_vec))
```

# Introduction

## Project Overview {.smaller}

::: {.panel-tabset}

### Details
- **Objective**: Time series analysis of ASML Holding NV's Adjusted Closing Prices
- **Data Source**: [Yahoo Finance](https://finance.yahoo.com/quote/ASML/)
- **Period**:
    - from: 2000-01-01
    - to: 2025-12-31.

### Dataframe

::: {style="font-size: 0.6em;"}

```{r}
#| label: show-table-data

datatable(
    tail(asml, 30),
    rownames = FALSE,
    options = list(
        scrollY = "350px",
        scrollCollapse = TRUE,
        paging = FALSE,
        dom = "t",
        order = list(list(0, 'desc'))
    )
) %>% 
  formatRound(
    columns = c("ASML.Open", "ASML.High", "ASML.Low", "ASML.Close", "ASML.Adjusted"), 
    digits = 2
  )
```

:::

:::

# EDA

## Adjusted Closing Prices {.smaller}

::: {.columns}

::: {.column width="65%"}

```{r}
#| label: plot-prices
#| echo: false
#| fig-width: 16
#| fig-height: 6
#| out-width: "100%"

fig_asml <- plot_ly(data = asml, x = ~Date, y = ~ASML.Adjusted, 
  type = 'scatter', mode = 'lines', name = 'ASML Adjusted',
  line = list(color = 'darkblue', width = 1.5)
) %>% layout(
  title = list(text = "ASML Stock Price Evolution", y = 0.98),
  xaxis = list(
    title = "Date",
    rangeslider = list(visible = TRUE)
  ),
  yaxis = list(title = "Adjusted price", fixedrange = FALSE),
  autosize = FALSE,
  width = 650,
  height = 550,
  margin = list(l = 50, r = 20, b = 40, t = 30, pad = 4)
)

fig_asml
```

:::

::: {.column width="35%"}

**Key Observations:**

::: {.incremental}

* The series is clearly **non-stationary**.
* Visible upward trend, especially post-2017.
* Variance increases with price level.
:::

:::

:::

## Log-Returns Visualization {.smaller}

```{r}
#| label: plot-log-returns
#| echo: false
#| fig-width: 16
#| fig-height: 6
#| out-width: "100%"

fig_log <- plot_ly(data = log_returns, x = ~Date, y = ~LogReturns, type = 'scatter',
    mode = 'lines', name = 'Log Returns', line = list(color = 'darkred', width = 1))

fig_log <- layout(
  fig_log,
  title = "ASML Log-Returns",
  xaxis = list(title = "Date"),
  yaxis = list(title = "Log Return"),
  shapes = list(
    list(
      type = "line",
      x0 = min(log_returns$Date),
      x1 = max(log_returns$Date),
      y0 = 0, 
      y1 = 0,
      line = list(color = "black", width = 1)
    )
  ),
  autosize = FALSE,
  width = 1000,
  height = 550,
  margin = list(l = 50, r = 20, b = 40, t = 30, pad = 4)
)

fig_log
```


## Graphical representation {.smaller}

::: {.panel-tabset}

### Histogram

```{r}
#| label: dist-plot
#| echo: false
#| fig-width: 16
#| fig-height: 6
#| out-width: "100%"

mu_ret <- mean(log_returns$LogReturns)
sd_ret <- sd(log_returns$LogReturns)

t_fit_fGarch <- stdFit(log_returns$LogReturns * 100)
t_params <- t_fit_fGarch$par
t_label <- sprintf("Student-t (df=%.2f)", t_params["nu"])

fig_dist <- plot_ly(data = log_returns, x = ~LogReturns,
  type = "histogram", name = "Log Returns", histnorm = "probability density",
  marker = list(color = "lightgray", line = list(color = "gray", width = 1)),
  opacity = 0.7)

x_seq <- seq(min(log_returns$LogReturns), max(log_returns$LogReturns), length.out = 500)

y_norm <- dnorm(x_seq, mean = mu_ret, sd = sd_ret)
y_t <- dstd(
  x_seq,
  mean = t_params["mean"]/100,
  sd = t_params["sd"]/100,
  nu = t_params["nu"]
)

fig_dist <- fig_dist %>%
  add_lines(
    x = x_seq,
    y = y_norm,
    name = "Normal Distribution",
    line = list(color = "#E74C3C", width = 2, dash = "dash"),
    inherit = FALSE
  ) %>% 
  
  add_lines(
    x = x_seq,
    y = y_t,
    name = t_label,
    line = list(color = "#2E86C1", width = 2),
    inherit = FALSE
  ) %>% 
  
  layout(
    title = "Distribution of ASML Log-Returns",
    xaxis = list(title = "Log Return"),
    yaxis = list(title = "Density"),
    legend = list(x = 0.8, y = 0.9),
    hovermode = "x unified",
    autosize = FALSE,
    width = 1000,
    height = 500,
    margin = list(l = 50, r = 20, b = 40, t = 30, pad = 4)
  )

fig_dist
```

### Q-Q plot

```{r}
#| label: dqq-plot
#| echo: false
#| fig-width: 16
#| fig-height: 6
#| out-width: "100%"

vec_ret <- log_returns$LogReturns

qq_vals <- qqnorm(vec_ret, plot.it = FALSE)
qq_data <- data.frame(
  Theoretical = qq_vals$x,
  Sample = qq_vals$y
)

y <- quantile(vec_ret, c(0.25, 0.75), names = FALSE)
x <- qnorm(c(0.25, 0.75))
slope <- diff(y)/diff(x)
int <- y[1L] - slope * x[1L]

fig_qq <- plot_ly(data = qq_data, x = ~Theoretical, y = ~Sample, type = 'scatter',
  mode = 'markers', marker = list(size = 3, color = '#2E86C1', opacity = 0.6),
  name = "Returns")

fig_qq <- fig_qq %>%
    add_lines(
      x = ~Theoretical,
      y = ~Theoretical * slope + int, 
      line = list(color = "#E74C3C", width = 2, dash = "dash"), 
      name = "Normal Reference",
      inherit = FALSE
    ) %>%
    
    layout(
      title = "Q-Q Plot: Normal vs Empirical",
      xaxis = list(title = "Theoretical Quantiles (Normal)"),
      yaxis = list(title = "Sample Quantiles (ASML)"),
      autosize = FALSE,
      width = 1000,
      height = 500,
      margin = list(l = 50, r = 20, b = 40, t = 30, pad = 4)
    )

fig_qq
```

:::

## Synthetic indicators {.smaller}

```{r}
#| label: calc-stats

desc_stats <- data.frame(
    Metric = c("Mean", "Std. Dev.", "Skewness", "Kurtosis"),
    Value = c(
        mean(log_returns$LogReturns),
        sd(log_returns$LogReturns),
        skewness(log_returns$LogReturns),
        kurtosis(log_returns$LogReturns)
    )
)

datatable(
    desc_stats, 
    options = list(dom = 't', paging = FALSE), 
    rownames = FALSE
) %>% formatRound('Value', digits = 5)
```

## Test of normality {.smaller}

```{r}
#| label: normality-test

jb_test <- jarque.bera.test(log_returns$LogReturns)

jb_res <- data.frame(
    Test = "Jarque-Bera",
    Statistic = round(jb_test$statistic, 2),
    P_Value = ifelse(jb_test$p.value < 0.001, "< 0.001", round(jb_test$p.value, 4)),
    Result = ifelse(jb_test$p.value < 0.05, "Reject H0", "Fail to Reject H0")
)

datatable(jb_res, options = list(dom = 't'), rownames = FALSE)
```

# Returns Analysis

## ACF and PACF {.smaller}

```{r}
#| label: acf-pacf-plots
#| message: false
#| fig-width: 16
#| fig-height: 6
#| out-width: "100%"

acf_res <- acf(log_returns$LogReturns, plot = FALSE, lag.max = 20)
pacf_res <- pacf(log_returns$LogReturns, plot = FALSE, lag.max = 20)

ci <- qnorm((1 + 0.95)/2)/sqrt(length(log_returns$LogReturns))

df_acf <- data.frame(lag = as.numeric(acf_res$lag)[-1], acf = as.numeric(acf_res$acf)[-1])
df_pacf <- data.frame(lag = as.numeric(pacf_res$lag), pacf = as.numeric(pacf_res$acf))

fig_acf <- plot_ly(df_acf, x = ~lag, y = ~acf, type = 'bar', name = 'ACF',
                   marker = list(color = '#1f77b4')) %>%
  add_segments(x = min(df_acf$lag), xend = max(df_acf$lag), y = ci, yend = ci, 
               line = list(color = 'red', dash = 'dash', width = 1), showlegend = FALSE) %>%
  add_segments(x = min(df_acf$lag), xend = max(df_acf$lag), y = -ci, yend = -ci, 
               line = list(color = 'red', dash = 'dash', width = 1), showlegend = FALSE) %>%
  layout(yaxis = list(title = "ACF"))

fig_pacf <- plot_ly(df_pacf, x = ~lag, y = ~pacf, type = 'bar', name = 'PACF',
                    marker = list(color = '#ff7f0e')) %>%
  add_segments(x = min(df_pacf$lag), xend = max(df_pacf$lag), y = ci, yend = ci, 
               line = list(color = 'red', dash = 'dash', width = 1), showlegend = FALSE) %>%
  add_segments(x = min(df_pacf$lag), xend = max(df_pacf$lag), y = -ci, yend = -ci, 
               line = list(color = 'red', dash = 'dash', width = 1), showlegend = FALSE) %>%
  layout(yaxis = list(title = "PACF"))

subplot(fig_acf, fig_pacf, nrows = 1, margin = 0.05, titleY = TRUE) %>%
  layout(title = "Autocorrelation & Partial Autocorrelation",
  autosize = FALSE,
  width = 1000,
  height = 550,
  margin = list(l = 50, r = 20, b = 40, t = 30, pad = 4)
)
```


## AIC vs BIC {.smaller}

```{r}
set.seed(123)

arma_10 <- Arima(log_returns$LogReturns, order=c(1,0,0))
arma_01 <- Arima(log_returns$LogReturns, order=c(0,0,1))
arma_11 <- Arima(log_returns$LogReturns, order=c(1,0,1))
arma_20 <- Arima(log_returns$LogReturns, order=c(2,0,0))
arma_02 <- Arima(log_returns$LogReturns, order=c(0,0,2))
arma_12 <- Arima(log_returns$LogReturns, order=c(1,0,2))
arma_21 <- Arima(log_returns$LogReturns, order=c(2,0,1))
arma_22 <- Arima(log_returns$LogReturns, order=c(2,0,2))
arma_30 <- Arima(log_returns$LogReturns, order=c(3,0,0))
arma_03 <- Arima(log_returns$LogReturns, order=c(0,0,3))
arma_13 <- Arima(log_returns$LogReturns, order=c(1,0,3))
arma_23 <- Arima(log_returns$LogReturns, order=c(2,0,3))
arma_31 <- Arima(log_returns$LogReturns, order=c(3,0,1))
arma_32 <- Arima(log_returns$LogReturns, order=c(3,0,2))
arma_33 <- Arima(log_returns$LogReturns, order=c(3,0,3))
```


```{r}
#| label: model-comparison
#| message: false
#| fig-width: 16
#| fig-height: 6
#| out-width: "100%"

models_list <- list(
  "AR(1)" = arma_10, "MA(1)" = arma_01, "ARMA(1,1)" = arma_11,
  "AR(2)" = arma_20, "MA(2)" = arma_02, "ARMA(1,2)" = arma_12,
  "ARMA(2,1)" = arma_21, "ARMA(2,2)" = arma_22,
  "AR(3)" = arma_30, "MA(3)" = arma_03, "ARMA(1,3)" = arma_13,
  "ARMA(2,3)" = arma_23, "ARMA(3,1)" = arma_31, "ARMA(3,2)" = arma_32,
  "ARMA(3,3)" = arma_33
)

metrics_df <- data.frame(
  Model = names(models_list),
  AIC = sapply(models_list, AIC),
  BIC = sapply(models_list, BIC)
)

metrics_df$Model <- factor(metrics_df$Model, levels = metrics_df$Model)

min_aic_val <- min(metrics_df$AIC)
min_bic_val <- min(metrics_df$BIC)

plot_aic <- plot_ly(metrics_df, x = ~Model, y = ~AIC, name = 'AIC',
  type = 'scatter', mode = 'lines+markers',
  line = list(color = '#1f77b4', width = 2),
  marker = list(size = 8, color = '#1f77b4')) %>% layout(title = "AIC Trend", yaxis = list(title = "AIC"))

best_aic <- metrics_df[metrics_df$AIC == min_aic_val, ]
plot_aic <- plot_aic %>%
  add_trace(data = best_aic, x = ~Model, y = ~AIC, 
    type = 'scatter', mode = 'markers', name = 'Best AIC',
    marker = list(color = 'red', size = 12, symbol = 'star'),
    showlegend = FALSE
  )

plot_bic <- plot_ly(metrics_df, x = ~Model, y = ~BIC, name = 'BIC',
  type = 'scatter', mode = 'lines+markers',
  line = list(color = '#ff7f0e', width = 2),
  marker = list(size = 8, color = '#ff7f0e')) %>% layout(title = "BIC Trend", yaxis = list(title = "BIC"))

best_bic <- metrics_df[metrics_df$BIC == min_bic_val, ]
plot_bic <- plot_bic %>%
  add_trace(
    data = best_bic, x = ~Model, y = ~BIC, 
    type = 'scatter', mode = 'markers', name = 'Best BIC',
    marker = list(color = 'red', size = 12, symbol = 'star'),
    showlegend = FALSE
  )

final_plot <- subplot(plot_aic, plot_bic, nrows = 2, shareX = TRUE, titleY = TRUE) %>%
  layout(
    title = "Model Selection Criteria: AIC & BIC Trends",
    hovermode = "x unified",
    autosize = FALSE,
    width = 1000,
    height = 550,
    margin = list(l = 50, r = 20, b = 40, t = 30, pad = 4)
  )

final_plot
```

## Forecast: plot {.smaller}

```{r}
#| label: compute-forecast

n_total <- nrow(log_returns)
n_train <- floor(0.80 * n_total)

train_data <- log_returns$LogReturns[1:n_train]
test_data <- log_returns$LogReturns[(n_train + 1):n_total]

set.seed(123)

mod_winner_bic <- Arima(train_data, order=c(1,0,1))
mod_winner_aic <- Arima(train_data, order=c(3,0,3))
mod_naive <- Arima(train_data, order=c(0,0,0)) 

h_steps <- length(test_data)

fc_bic <- forecast(mod_winner_bic, h=h_steps)
fc_aic <- forecast(mod_winner_aic, h=h_steps)
fc_naive <- forecast(mod_naive, h=h_steps)
```

::: {.panel-tabset}

### One-Steap-Ahead {.smaller}
```{r}
#| label: rolling-forecast
#| fig-width: 16
#| fig-height: 6
#| out-width: "100%"
fit_bic_rolling <- Arima(log_returns$LogReturns, model = mod_winner_bic)
one_step_bic <- fitted(fit_bic_rolling)[(n_train + 1):n_total]

fit_aic_rolling <- Arima(log_returns$LogReturns, model = mod_winner_aic)
one_step_aic <- fitted(fit_aic_rolling)[(n_train + 1):n_total]

dates_test  <- log_returns$Date[(n_train + 1):n_total]

fig_roll <- plot_ly(
  x = dates_test, 
  y = test_data, 
  type = 'scatter', 
  mode = 'lines', 
  name = 'Actual Test Data', 
  line = list(color = 'black', width = 1, dash = 'dot')
)

fig_roll <- add_trace(
  fig_roll, 
  x = dates_test, 
  y = as.numeric(one_step_bic), 
  name = 'Rolling ARMA(1,1)', 
  line = list(color = 'blue', width = 1)
)

fig_roll <- add_trace(
  fig_roll, 
  x = dates_test, 
  y = as.numeric(one_step_aic), 
  name = 'Rolling ARMA(3,3)', 
  line = list(color = 'red', width = 1)
)

fig_roll <- layout(
  fig_roll,
  title = "One-Step-Ahead Rolling Forecast (Test Set: 20%)",
  xaxis = list(title = "Date"),
  yaxis = list(title = "Log Return"),
  legend = list(orientation = "h", x = 0.1, y = -0.2),
  autosize = FALSE,
  width = 1000,
  height = 550,
  margin = list(l = 50, r = 20, b = 40, t = 30, pad = 4)
)

fig_roll
```

### Five-Steap-Ahead {.smaller}
```{r}
#| label: rolling-forecast-5step
#| fig-width: 16
#| fig-height: 6
#| out-width: "100%"

calc_k_step_rolling <- function(model_obj, series, n_train, k=5) {
  n_total <- length(series)
  test_indices <- (n_train + 1):n_total
  forecasts <- numeric(length(test_indices))
  
  for (i in seq_along(test_indices)) {
    target_idx <- test_indices[i]
    origin_idx <- target_idx - k
    
    if (origin_idx > 0) {
      subset_data <- series[1:origin_idx]
      fit_temp <- Arima(subset_data, model = model_obj)
      
      fc_temp <- forecast(fit_temp, h = k)
      
      forecasts[i] <- as.numeric(fc_temp$mean[k])
    } else {
      forecasts[i] <- NA
    }
  }
  return(forecasts)
}

k_horizon <- 5
vec_5step_bic <- calc_k_step_rolling(mod_winner_bic, log_returns$LogReturns, n_train, k = k_horizon)
vec_5step_aic <- calc_k_step_rolling(mod_winner_aic, log_returns$LogReturns, n_train, k = k_horizon)

dates_test <- log_returns$Date[(n_train + 1):n_total]

fig_roll_5 <- plot_ly(
  x = dates_test, 
  y = test_data, 
  type = 'scatter', 
  mode = 'lines', 
  name = 'Actual Test Data', 
  line = list(color = 'black', width = 1, dash = 'dot')
)

fig_roll_5 <- add_trace(
  fig_roll_5, 
  x = dates_test, 
  y = vec_5step_bic, 
  name = "Rolling ARMA(1,1)", 
  line = list(color = 'blue', width = 1.5)
)

fig_roll_5 <- add_trace(
  fig_roll_5, 
  x = dates_test, 
  y = vec_5step_aic, 
  name = "Rolling ARMA(3,3)", 
  line = list(color = 'red', width = 1.5)
)

fig_roll_5 <- layout(
  fig_roll_5,
  title = "Five-Step-Ahead Rolling Forecast (Test Set: 20%)",
  xaxis = list(title = "Date"),
  yaxis = list(title = "Log Return"),
  legend = list(orientation = "h", x = 0.1, y = -0.2),
  autosize = FALSE,
  width = 1000,
  height = 550,
  margin = list(l = 50, r = 20, b = 40, t = 30, pad = 4)
)

fig_roll_5
```

:::

## Forecast: metrics {.smaller}

```{r}
#| label: forecast-validation

get_metrics_robust <- function(forecast_obj, actuals) {
  vec_pred <- as.numeric(forecast_obj$mean)
  vec_obs <- as.numeric(actuals)
  
  acc <- accuracy(vec_pred, vec_obs)
  
  return(c(RMSE = acc[1, "RMSE"], MAE = acc[1, "MAE"]))
}

res_bic <- get_metrics_robust(fc_bic, test_data)
res_aic <- get_metrics_robust(fc_aic, test_data)
res_naive <- get_metrics_robust(fc_naive, test_data)

u_bic <- res_bic["RMSE"] / res_naive["RMSE"]
u_aic <- res_aic["RMSE"] / res_naive["RMSE"]
u_naive <- 1.0

validation_table <- data.frame(
  Model = c("ARMA(1,1) [BIC Winner]", "ARMA(3,3) [AIC Winner]", "Naive (Benchmark)"),
  RMSE = c(res_bic["RMSE"], res_aic["RMSE"], res_naive["RMSE"]),
  MAE = c(res_bic["MAE"], res_aic["MAE"], res_naive["MAE"]),
  Theil_U2 = c(u_bic, u_aic, u_naive)
)

datatable(validation_table, options = list(dom = 't'), rownames = FALSE) %>% 
  formatRound(
    columns = c("RMSE", "MAE", "Theil_U2"), 
    digits = 5
  )
```

# Volatility Analysis

```{r}
log_returns$Squared <- log_returns$LogReturns^2
log_returns$Abs <- abs(log_returns$LogReturns)
```


## Squared and Absolute Returns {.smaller}

::: {.panel-tabset}

### Squared Returns {.smaller}
```{r}
#| label: plot-squared-returns
#| fig-width: 16
#| fig-height: 6
#| out-width: "100%"

fig_sq <- plot_ly(data = log_returns, x = ~Date, y = ~Squared, type = 'scatter',
  mode = 'lines', name = 'Squared Returns', line = list(color = 'darkred', width = 1))

fig_sq <- layout(
  fig_sq,
  title = "ASML Squared Log-Returns",
  xaxis = list(title = "Date"),
  yaxis = list(title = "Squared Log Return"),
  shapes = list(
    list(
      type = "line",
      x0 = min(log_returns$Date),
      x1 = max(log_returns$Date),
      y0 = 0, 
      y1 = 0,
      line = list(color = "black", width = 1)
    )
  ),
  autosize = FALSE,
  width = 1000,
  height = 550,
  margin = list(l = 50, r = 20, b = 40, t = 30, pad = 4)
)

fig_sq
```

### Absolute Returns {.smaller}
```{r}
#| label: plot-absolute-value-returns
#| fig-width: 16
#| fig-height: 6
#| out-width: "100%"

fig_sq <- plot_ly(data = log_returns, x = ~Date, y = ~Abs, type = 'scatter',
  mode = 'lines', name = 'Absolute Returns', line = list(color = 'darkred', width = 1))

fig_sq <- layout(
  fig_sq,
  title = "ASML Absolute Log-Returns",
  xaxis = list(title = "Date"),
  yaxis = list(title = "Absolute value Log Return"),
  shapes = list(
    list(
      type = "line",
      x0 = min(log_returns$Date),
      x1 = max(log_returns$Date),
      y0 = 0, 
      y1 = 0,
      line = list(color = "black", width = 1)
    )
  ),
  autosize = FALSE,
  width = 1000,
  height = 550,
  margin = list(l = 50, r = 20, b = 40, t = 30, pad = 4)
)

fig_sq
```

:::

## ACF vs PACF {.smaller}

::: {.panel-tabset}

### Squared Returns {.smaller}

```{r}
#| label: acf-pacf-squared
#| fig-width: 16
#| fig-height: 6
#| out-width: "100%"

acf_sq <- acf(log_returns$Squared, plot = FALSE, lag.max = 30)
pacf_sq <- pacf(log_returns$Squared, plot = FALSE, lag.max = 30)

ci <- qnorm((1 + 0.95)/2)/sqrt(length(log_returns$Squared))

df_acf_sq <- data.frame(
  lag = as.numeric(acf_sq$lag)[-1],
  acf = as.numeric(acf_sq$acf)[-1])

df_pacf_sq <- data.frame(
  lag = as.numeric(pacf_sq$lag),
  pacf = as.numeric(pacf_sq$acf))

fig_acf_sq <- plot_ly(df_acf_sq, x = ~lag, y = ~acf, type = 'bar', name = 'ACF',
  marker = list(color = '#1f77b4')) %>%
  
  add_segments(x = min(df_acf_sq$lag), xend = max(df_acf_sq$lag), y = ci, yend = ci, 
  line = list(color = 'red', dash = 'dash', width = 1), showlegend = FALSE) %>%
  
  add_segments(x = min(df_acf_sq$lag), xend = max(df_acf_sq$lag), y = -ci, yend = -ci, 
  line = list(color = 'red', dash = 'dash', width = 1), showlegend = FALSE) %>%
  
  layout(yaxis = list(title = "ACF"))

fig_pacf_sq <- plot_ly(df_pacf_sq, x = ~lag, y = ~pacf, type = 'bar', name = 'PACF',
  marker = list(color = '#ff7f0e')) %>%
  
  add_segments(x = min(df_pacf_sq$lag), xend = max(df_pacf_sq$lag), y = ci, yend = ci, 
  line = list(color = 'red', dash = 'dash', width = 1), showlegend = FALSE) %>%
  
  add_segments(x = min(df_pacf_sq$lag), xend = max(df_pacf_sq$lag), y = -ci, yend = -ci, 
  line = list(color = 'red', dash = 'dash', width = 1), showlegend = FALSE) %>%
  
  layout(yaxis = list(title = "PACF"))

subplot(fig_acf_sq, fig_pacf_sq, nrows = 1, margin = 0.05, titleY = TRUE) %>%
  layout(title = "Squared Returns: Autocorrelation & Partial Autocorrelation",
  autosize = FALSE,
  width = 1000,
  height = 550,
  margin = list(l = 50, r = 20, b = 40, t = 30, pad = 4) 
)
```

### Absolute Returns {.smaller}

```{r}
#| label: acf-pacf-absolute
#| fig-width: 16
#| fig-height: 6
#| out-width: "100%"


acf_abs <- acf(log_returns$Abs, plot = FALSE, lag.max = 30)
pacf_abs <- pacf(log_returns$Abs, plot = FALSE, lag.max = 30)

ci <- qnorm((1 + 0.95)/2)/sqrt(length(log_returns$Abs))

df_acf_abs <- data.frame(
  lag = as.numeric(acf_abs$lag)[-1],
  acf = as.numeric(acf_abs$acf)[-1])

df_pacf_abs <- data.frame(
  lag = as.numeric(pacf_abs$lag),
  pacf = as.numeric(pacf_abs$acf))

fig_acf_abs <- plot_ly(df_acf_abs, x = ~lag, y = ~acf, type = 'bar', name = 'ACF',
  marker = list(color = '#1f77b4')) %>%
  
  add_segments(x = min(df_acf_abs$lag), xend = max(df_acf_abs$lag), y = ci, yend = ci, 
  line = list(color = 'red', dash = 'dash', width = 1), showlegend = FALSE) %>%
  
  add_segments(x = min(df_acf_abs$lag), xend = max(df_acf_abs$lag), y = -ci, yend = -ci, 
  line = list(color = 'red', dash = 'dash', width = 1), showlegend = FALSE) %>%
  
  layout(yaxis = list(title = "ACF"))

fig_pacf_abs <- plot_ly(df_pacf_abs, x = ~lag, y = ~pacf, type = 'bar', name = 'PACF',
  marker = list(color = '#ff7f0e')) %>%
  
  add_segments(x = min(df_pacf_abs$lag), xend = max(df_pacf_abs$lag), y = ci, yend = ci, 
  line = list(color = 'red', dash = 'dash', width = 1), showlegend = FALSE) %>%
  
  add_segments(x = min(df_pacf_abs$lag), xend = max(df_pacf_abs$lag), y = -ci, yend = -ci, 
  line = list(color = 'red', dash = 'dash', width = 1), showlegend = FALSE) %>%
  
  layout(yaxis = list(title = "PACF"))

subplot(fig_acf_abs, fig_pacf_abs, nrows = 1, margin = 0.05, titleY = TRUE) %>%
  layout(title = "Absolute Returns: Autocorrelation & Partial Autocorrelation",
  autosize = FALSE,
  width = 1000,
  height = 550,
  margin = list(l = 50, r = 20, b = 40, t = 30, pad = 4) 
)
```

:::

## Testing for ARCH Effects and Asymmetry {.smaller}

::: {.panel-tabset}

### ARCH Effects {.smaller}
```{r}
#| label: arch-lm-only

arma_fit <- Arima(log_returns$LogReturns, order = c(1,0,1))
residuals_arma <- residuals(arma_fit)

lags_to_test <- c(5, 10, 20)

run_arch_lm <- function(lag_val) {  
  lm_test <- ArchTest(residuals_arma, lags = lag_val)
  
  return(data.frame(
    Lag = lag_val,
    Statistic = lm_test$statistic,
    P_Value = lm_test$p.value
  ))
}

arch_results <- do.call(rbind, lapply(lags_to_test, run_arch_lm))

arch_display <- arch_results %>%
  mutate(
    Conclusion = ifelse(P_Value < 0.05, "Reject H0", "Fail to Reject"),
    P_Value = format.pval(P_Value, digits = 3, eps = 0.001)
  )

knitr::kable(arch_display,
  caption = "Engle's ARCH-LM Test for Volatility Clustering",
  align = "c", row.names = FALSE)
```

### Leverage Effects {.smaller}

```{r}
#| label: leverage-effect-tests

spec_std <- ugarchspec(
  variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
  mean.model = list(armaOrder = c(1, 1), include.mean = TRUE),
  distribution.model = "std"
)

fit_std <- ugarchfit(spec = spec_std, data = log_returns$LogReturns)
engle_test <- signbias(fit_std)

engle_df <- data.frame(
  Test = rownames(engle_test),
  t_value = engle_test[, 1],
  Prob = engle_test[, 2],
  Result = ifelse(engle_test[, 2] < 0.05, "Asymmetry", "Symmetry")
)

engle_df$Prob <- format.pval(engle_df$Prob, digits = 3, eps = 0.001)

knitr::kable(engle_df, 
  digits = 4, 
  caption = "Engle-Ng Tests for Asymmetry (Leverage Effect)",
  row.names = FALSE,
  align = "c")
```

:::

## Forecast: plot {.smaller}

```{r}
#| label: setup-garch-forecast
#| message: false
#| warning: false

n_total <- nrow(log_returns)
n_train <- floor(0.80 * n_total)
n_test  <- n_total - n_train

common_mean <- list(armaOrder = c(1, 1), include.mean = TRUE)
common_dist <- "std"

spec_std <- ugarchspec(
  variance.model = list(model = "sGARCH", garchOrder = c(1, 1)), 
  mean.model = common_mean, distribution.model = common_dist)

spec_gjr <- ugarchspec(
  variance.model = list(model = "gjrGARCH", garchOrder = c(1, 1)), 
  mean.model = common_mean, distribution.model = common_dist)

spec_egarch <- ugarchspec(
  variance.model = list(model = "eGARCH", garchOrder = c(1, 1)), 
  mean.model = common_mean, distribution.model = common_dist)

roll_std <- ugarchroll(
  spec_std, data = log_returns$LogReturns, n.ahead = 1, 
  n.start = n_train, refit.every = 50, refit.window = "moving", solver = "hybrid")

roll_gjr <- ugarchroll(
  spec_gjr, data = log_returns$LogReturns, n.ahead = 1, 
  n.start = n_train, refit.every = 50, refit.window = "moving", solver = "hybrid")

roll_egarch <- ugarchroll(
  spec_egarch, data = log_returns$LogReturns, n.ahead = 1, 
  n.start = n_train, refit.every = 50, refit.window = "moving", solver = "hybrid")
```

```{r}
#| label: plot-vol-unified
#| fig-width: 16
#| fig-height: 6
#| out-width: "100%"


df_plot <- as.data.frame(roll_egarch)

df_plot$Date <- log_returns$Date[(n_train + 1):n_total]
df_plot$AbsReturn <- abs(df_plot$Realized)
df_plot$Sigma_EGARCH <- df_plot$Sigma
df_plot$Sigma_GJR <- as.data.frame(roll_gjr)$Sigma
df_plot$Sigma_STD <- as.data.frame(roll_std)$Sigma

fig_unified <- plot_ly(data = df_plot, x = ~Date) %>%
  
  add_bars(y = ~AbsReturn, name = 'Abs Returns (|r|)', 
  marker = list(color = 'lightgrey'), opacity = 0.5) %>%
  
  add_lines(y = ~Sigma_STD, name = 'sGARCH',
  line = list(color = 'green', width = 1.5)) %>%
  
  add_lines(y = ~Sigma_GJR, name = 'GJR-GARCH',
  line = list(color = 'steelblue', width = 1.5)) %>%
  
  add_lines(y = ~Sigma_EGARCH, name = 'E-GARCH',
  line = list(color = 'darkorange', width = 1.5)) %>%
  
  layout(
    title = "Volatility Forecast Comparison (Refit Window: 50 Days)",
    yaxis = list(title = "Volatility (Sigma)"),
    xaxis = list(title = "Date"),
    legend = list(orientation = "h", x = 0.1, y = -0.2),
    barmode = "overlay",
    hovermode = "x unified",
    autosize = FALSE,
    width = 1000,
    height = 550,
    margin = list(l = 50, r = 20, b = 40, t = 30, pad = 4)
  )

fig_unified
```

## Forecast: metrics {.smaller}

```{r}
#| label: vol-forecast-validation

calc_vol_metrics <- function(roll_obj, name) {
  df <- as.data.frame(roll_obj)
  actual_var <- df$Realized^2
  pred_var   <- df$Sigma^2
  
  rmse <- sqrt(mean((actual_var - pred_var)^2))
  qlike <- mean(log(pred_var) + (actual_var / pred_var))
  
  return(c(Model = name, RMSE = rmse, QLIKE = qlike))
}

m_std <- calc_vol_metrics(roll_std, "sGARCH(1,1)")
m_gjr <- calc_vol_metrics(roll_gjr, "GJR-GARCH(1,1)")
m_eg <- calc_vol_metrics(roll_egarch, "E-GARCH(1,1)")

vol_val_table <- data.frame(rbind(m_std, m_gjr, m_eg))
vol_val_table$RMSE <- as.numeric(vol_val_table$RMSE)
vol_val_table$QLIKE <- as.numeric(vol_val_table$QLIKE)
vol_val_table <- vol_val_table[order(vol_val_table$QLIKE), ]

datatable(vol_val_table, options = list(dom = 't'), rownames = FALSE) %>%
  formatRound(columns = c('RMSE', 'QLIKE'), digits = 5)
```

## Value at Risk (VaR) {.smaller}

```{r}
#| label: var-calculation
#| fig-width: 16
#| fig-height: 6
#| out-width: "100%"

sigma_t <- sigma(fit_std)
mu_t    <- fitted(fit_std)
shape_param <- coef(fit_std)["shape"]

q_05 <- qdist(distribution = "std", p = 0.05, shape = shape_param)
q_01 <- qdist(distribution = "std", p = 0.01, shape = shape_param)

VaR_95 <- mu_t + sigma_t * q_05
VaR_99 <- mu_t + sigma_t * q_01

df_risk <- data.frame(
  Date = log_returns$Date,
  Returns = log_returns$LogReturns,
  VaR_95 = as.numeric(VaR_95),
  VaR_99 = as.numeric(VaR_99)
)

fig_var <- plot_ly(df_risk, x = ~Date)

fig_var <- add_trace(
  fig_var, y = ~Returns, type = 'scatter', mode = 'lines',
  name = 'Log Returns', line = list(color = 'grey', width = 0.5, opacity = 0.5)
)

fig_var <- add_trace(
  fig_var, y = ~VaR_95, type = 'scatter', mode = 'lines',
  name = 'VaR 95% (sGARCH)', line = list(color = 'orange', width = 1.5)
)

fig_var <- add_trace(
  fig_var, y = ~VaR_99, type = 'scatter', mode = 'lines',
  name = 'VaR 99% (sGARCH)', line = list(color = 'darkred', width = 1.5)
)

fig_var <- layout(
  fig_var,
  title = "Risk Management: ASML Returns vs Dynamic VaR (sGARCH)",
  yaxis = list(title = "Log Return"),
  xaxis = list(title = "Date"),
  legend = list(orientation = "h", x = 0.1, y = -0.2),
  autosize = FALSE,
  width = 1000,
  height = 550,
  margin = list(l = 50, r = 20, b = 40, t = 30, pad = 4)
)

fig_var
```

#  {.center}

::: {.r-fit-text}
Thanks!
:::

<br>

**Author:** Daniele Tambone